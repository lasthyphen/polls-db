"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStats = exports.statsWorker = void 0;
const lodash_1 = require("lodash");
const db_1 = require("../db/db");
const Job_1 = require("../db/models/Job");
const breakout_1 = require("../utils/breakout");
const logger_1 = require("../utils/logger");
const promises_1 = require("../utils/promises");
const timer_1 = require("../utils/timer");
const logger = logger_1.getLogger('stats');
async function statsWorker(services) {
    const statsCfg = services.config.statsWorker;
    logger.info('Stats process starting...');
    let lastStat;
    while (true && !breakout_1.getSpockBreakout()) {
        const startTime = Date.now();
        logger.info(`Sleeping for ${statsCfg.interval} sec...`);
        await promises_1.delay(statsCfg.interval * 1000 * 60);
        logger.info('Calculating stats...');
        const stopTime = Date.now();
        const stats = await getStats(services);
        if (lastStat) {
            const blocksSyncedDelta = stats.blocksSynced - lastStat.blocksSynced;
            const blocksExtractedDelta = stats.blocksExtracted - lastStat.blocksExtracted;
            const blocksTransformedDelta = stats.blocksTransformed - lastStat.blocksTransformed;
            const timeDeltaSec = (stopTime - startTime) / 1000;
            logger.info(`
Stats on ${new Date(stopTime).toUTCString()}}:
synced: ${(blocksSyncedDelta / timeDeltaSec).toFixed(2)} blocks/sec
extracted: ${(blocksExtractedDelta / timeDeltaSec).toFixed(2)} tasks/sec
transformed: ${(blocksTransformedDelta / timeDeltaSec).toFixed(2)} tasks/sec
      `);
            timer_1.printTimersSummary();
        }
        else {
            logger.info('Missing baseline');
        }
        lastStat = stats;
    }
}
exports.statsWorker = statsWorker;
async function getStats(services) {
    return await db_1.withConnection(services.db, async (c) => {
        const blocksSynced = ((await c.oneOrNone(`SELECT id FROM ${services.processorSchema}.block ORDER BY number DESC LIMIT 1;
  `)) || {}).id || 0;
        const allJobs = await Job_1.getAllJobs(c, services.processorSchema);
        const allJobsByName = lodash_1.groupBy(allJobs, 'name');
        const extractors = lodash_1.flatten(lodash_1.values(lodash_1.pick(allJobsByName, services.config.extractors.map((e) => e.name))));
        const blocksExtracted = sumWork(extractors);
        const transformers = lodash_1.flatten(lodash_1.values(lodash_1.pick(allJobsByName, services.config.transformers.map((e) => e.name))));
        const blocksTransformed = sumWork(transformers);
        return {
            blocksSynced,
            blocksExtracted,
            blocksTransformed,
        };
    });
}
exports.getStats = getStats;
function sumWork(job) {
    return job.reduce((a, c) => a + c.last_block_id, 0);
}
//# sourceMappingURL=stats.js.map