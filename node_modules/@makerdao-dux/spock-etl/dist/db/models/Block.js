"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.insertBlocksBatch = exports.removeBlockByHash = exports.getLastBlockNumber = exports.getBlockRange = exports.getBlockByIdOrDie = exports.getBlockByNumber = exports.getBlockById = exports.getBlock = void 0;
const db_1 = require("../db");
async function getBlock(c, blockHash, schema) {
    return c.oneOrNone(`SELECT * FROM ${schema}.block WHERE hash=$1;`, blockHash).then(db_1.makeNullUndefined);
}
exports.getBlock = getBlock;
async function getBlockById(c, id, schema) {
    return c.oneOrNone(`SELECT * FROM ${schema}.block WHERE id=$1;`, id).then(db_1.makeNullUndefined);
}
exports.getBlockById = getBlockById;
async function getBlockByNumber(c, id, schema) {
    return c.oneOrNone(`SELECT * FROM ${schema}.block WHERE number=$1;`, id).then(db_1.makeNullUndefined);
}
exports.getBlockByNumber = getBlockByNumber;
async function getBlockByIdOrDie(c, id, schema) {
    return c
        .oneOrNone(`SELECT * FROM ${schema}.block WHERE id=$1;`, id)
        .then(db_1.makeNullUndefined)
        .then((r) => {
        if (!r) {
            throw new Error(`Block(id=${id}) is missing`);
        }
        return r;
    });
}
exports.getBlockByIdOrDie = getBlockByIdOrDie;
async function getBlockRange(c, start, end, schema) {
    const sql = `
SELECT * FROM ${schema}.block
WHERE id >= ${start} AND id <= ${end}
  `;
    return c.manyOrNone(sql);
}
exports.getBlockRange = getBlockRange;
async function getLastBlockNumber(c, schema) {
    const lastBlock = await c.oneOrNone(`SELECT number FROM ${schema}.block ORDER BY number DESC LIMIT 1;`);
    return lastBlock === null || lastBlock === void 0 ? void 0 : lastBlock.number;
}
exports.getLastBlockNumber = getLastBlockNumber;
async function removeBlockByHash(c, blockHash, schema) {
    await c.none('DELETE FROM ' + schema + '.block WHERE hash=${hash};', {
        hash: blockHash,
    });
}
exports.removeBlockByHash = removeBlockByHash;
async function insertBlocksBatch(c, pg, blocks, schema) {
    const BLOCK_COLUMN_SET = new pg.helpers.ColumnSet(['number', 'hash', 'timestamp'], {
        table: new pg.helpers.TableName({ table: 'block', schema }),
    });
    const addBlocksQuery = pg.helpers.insert(blocks, BLOCK_COLUMN_SET) + 'ON CONFLICT(hash) DO NOTHING RETURNING *';
    const persistedBlocks = await c.manyOrNone(addBlocksQuery);
    if (!persistedBlocks || persistedBlocks.length === 0) {
        return [];
    }
    return persistedBlocks || [];
}
exports.insertBlocksBatch = insertBlocksBatch;
//# sourceMappingURL=Block.js.map