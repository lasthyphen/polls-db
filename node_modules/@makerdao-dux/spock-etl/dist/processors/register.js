"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerChain = exports.registerProcessors = void 0;
const lodash_1 = require("lodash");
const db_1 = require("../db/db");
const Block_1 = require("../db/models/Block");
const Chain_1 = require("../db/models/Chain");
const Job_1 = require("../db/models/Job");
const logger_1 = require("../utils/logger");
const types_1 = require("./types");
const logger = logger_1.getLogger('register');
/**
 * Prepares vulcan2x.job table with all processors. Note: this should be called just once per ETL start!
 */
async function registerProcessors(services, processors) {
    validateIntegrity(processors);
    await db_1.withConnection(services.db, async (c) => {
        logger.info('De-registering all processors...');
        await Job_1.excludeAllJobs(c, services.processorSchema);
        logger.info(`Registering configured processors(${processors.length})...`);
        for (const processor of processors) {
            await registerProcessor(c, processor, services.processorSchema);
        }
    });
}
exports.registerProcessors = registerProcessors;
function validateChainName(services) {
    // Ethers default response if network name is not found
    return services.networkState.networkName.name === 'unknown'
        ? services.config.chain.name
        : services.networkState.networkName.name;
}
async function registerChain(services) {
    await db_1.withConnection(services.db, async (c) => {
        const chainName = validateChainName(services);
        logger.info(`Attempting to add chain ${chainName} to database...`);
        const chainModel = await Chain_1.getChain(c, chainName);
        if (chainModel) {
            logger.info(`Chain name ${chainName} already exists in database, not adding`);
            return;
        }
        else {
            const newChain = {
                name: chainName,
                chain_id: services.networkState.networkName.chainId,
            };
            logger.info(`Adding chain ${chainName} to database`);
            await Chain_1.saveChain(c, newChain);
        }
    });
}
exports.registerChain = registerChain;
async function registerProcessor(c, processor, schema) {
    const jobModel = await Job_1.getJob(c, processor.name, schema);
    if (jobModel) {
        logger.info(
        // prettier-ignore
        `Setting processor ${processor.name} status to 'processing'. Previously: '${jobModel.status}'`);
        await Job_1.setJobStatus(c, jobModel, 'processing', schema);
    }
    else {
        const newJob = {
            name: processor.name,
            last_block_id: await getStartingBlockId(c, processor, schema),
            status: 'processing',
        };
        logger.info(`Registering a new processor ${processor.name}: (${JSON.stringify(newJob)})`);
        await Job_1.saveJob(c, newJob, schema);
    }
}
async function getStartingBlockId(c, processor, schema) {
    if (processor.startingBlock === undefined) {
        return 0;
    }
    const block = await Block_1.getBlockByNumber(c, processor.startingBlock, schema);
    if (block === undefined) {
        logger.warn(`Can't find starting block for ${processor.name}. BlockNumber: ${processor.startingBlock} is not yet synced. It will sync from the global start block`);
        return 0;
    }
    return block.id;
}
function validateIntegrity(processors) {
    checkNameUniqueness(processors);
    checkDependencies(processors);
}
function checkNameUniqueness(processors) {
    const uniqueNames = new Set();
    const names = processors.map((p) => p.name);
    for (const name of names) {
        if (uniqueNames.has(name)) {
            throw new Error(`${name} processor name is not unique!`);
        }
        uniqueNames.add(name);
    }
}
// ensures that all dependencies exist
function checkDependencies(processors) {
    const allNames = processors.map((p) => p.name);
    for (const processor of processors) {
        if (types_1.isExtractor(processor)) {
            const diff = lodash_1.difference(processor.extractorDependencies || [], allNames);
            if (diff.length > 0) {
                throw new Error(`Processor ${processor.name} has extractorDependencies that couldn't be find: ${diff.join(', ')}`);
            }
        }
        else {
            const diff = lodash_1.difference(processor.dependencies || [], allNames);
            if (diff.length > 0) {
                throw new Error(`Processor ${processor.name} has dependencies that couldn't be find: ${diff.join(', ')}`);
            }
            const diff2 = lodash_1.difference(processor.transformerDependencies || [], allNames);
            if (diff2.length > 0) {
                throw new Error(`Processor ${processor.name} has transformerDependencies that couldn't be find: ${diff2.join(', ')}`);
            }
        }
    }
}
//# sourceMappingURL=register.js.map