"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockGenerator = void 0;
const lodash_1 = require("lodash");
const ts_essentials_1 = require("ts-essentials");
const Block_1 = require("../db/models/Block");
const arrays_1 = require("../utils/arrays");
const breakout_1 = require("../utils/breakout");
const logger_1 = require("../utils/logger");
const logger = logger_1.getLogger('block-generator');
class BlockGenerator {
    constructor(services) {
        this.services = services;
    }
    async init() {
        this.connection = await this.services.db.connect();
        this.schema = this.services.processorSchema;
    }
    async deinit() {
        this.connection.done();
    }
    async run(fromBlockNo, toBlockNo) {
        const isFromBlockMissing = !(await Block_1.getBlockByNumber(this.connection, fromBlockNo, this.schema));
        if (isFromBlockMissing) {
            logger.warn(`Initial block is missing. Starting from ${fromBlockNo}`);
            const blocks = await getRealBlocksStartingFrom(this.services, fromBlockNo);
            await Block_1.insertBlocksBatch(this.connection, this.services.pg, blocks.map(block2BlockModel), this.schema);
        }
        const lastBlockNumber = await Block_1.getLastBlockNumber(this.connection, this.schema);
        ts_essentials_1.assert(lastBlockNumber, `Last block couldn't be found. It should never happen at this point`);
        let currentBlockNo = lastBlockNumber + 1;
        // eslint-disable-next-line
        while (toBlockNo ? currentBlockNo < toBlockNo : true && !breakout_1.getSpockBreakout()) {
            logger.info('Waiting for block:', currentBlockNo);
            const blocks = await getRealBlocksStartingFrom(this.services, currentBlockNo);
            const previousBlock = await Block_1.getBlockByNumber(this.connection, currentBlockNo - 1, this.schema);
            ts_essentials_1.assert(previousBlock, 'previousBlock should be defined');
            if (!verifyBlocksConsistency(previousBlock, blocks)) {
                currentBlockNo = currentBlockNo - 1;
                logger.warn(`Backtracking to: ${currentBlockNo}`);
                await Block_1.removeBlockByHash(this.connection, previousBlock.hash, this.schema);
                continue;
            }
            logger.info(`Adding ${blocks.length} new blocks.`);
            await Block_1.insertBlocksBatch(this.connection, this.services.pg, blocks.map(block2BlockModel), this.schema);
            currentBlockNo = arrays_1.getLast(blocks).number + 1;
        }
    }
}
exports.BlockGenerator = BlockGenerator;
function block2BlockModel(block) {
    return {
        number: block.number,
        hash: block.hash,
        timestamp: new Date(block.timestamp * 1000),
    };
}
async function getRealBlocksStartingFrom({ config, provider }, blockNo) {
    logger.info(`Looking for ${config.blockGenerator.batch} external blocks starting from: ${blockNo}`);
    const blocks = lodash_1.compact(await Promise.all([...Array(config.blockGenerator.batch).keys()].map((offset) => provider.getBlock(blockNo + offset))));
    logger.info(`Got ${blocks.length} external blocks`);
    if (blocks.length !== 0) {
        return blocks;
    }
    return new Promise((resolve, reject) => {
        async function handleBlock(currentBlockNo) {
            try {
                if (currentBlockNo >= blockNo) {
                    provider.removeListener('block', handleBlock);
                    const block = await provider.getBlock(blockNo);
                    if (!block) {
                        reject(new Error("Couldn't get new block"));
                    }
                    resolve([block]);
                }
            }
            catch {
                reject(new Error("Couldn't get new block"));
            }
        }
        provider.on('block', handleBlock);
    });
}
function verifyBlocksConsistency(previousBlock, newBlocks) {
    let parentHash = previousBlock.hash;
    for (const block of newBlocks) {
        if (parentHash !== block.parentHash) {
            return false;
        }
        parentHash = block.hash;
    }
    return true;
}
//# sourceMappingURL=blockGenerator.js.map