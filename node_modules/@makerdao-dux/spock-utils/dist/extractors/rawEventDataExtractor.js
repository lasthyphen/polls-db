"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLogs = exports.getExtractorName = exports.getPersistedLogs = exports.extractRawLogs = exports.makeRawLogExtractors = void 0;
const getNetworkState_1 = require("@makerdao-dux/spock-etl/dist/ethereum/getNetworkState");
const arrays_1 = require("@makerdao-dux/spock-etl/dist/utils/arrays");
const timer_1 = require("@makerdao-dux/spock-etl/dist/utils/timer");
const lodash_1 = require("lodash");
const util_1 = require("util");
const common_1 = require("./common");
function makeRawLogExtractors(_extractors) {
    const extractors = _extractors.map((a) => {
        const address = util_1.isString(a) ? a.toLowerCase() : a.address.toLowerCase();
        const startingBlock = util_1.isString(a) ? undefined : a.startingBlock;
        return {
            address,
            startingBlock,
        };
    });
    return extractors.map((extractor) => ({
        name: getExtractorName(extractor.address),
        startingBlock: extractor.startingBlock,
        extract: async (services, blocks) => {
            await extractRawLogs(services, blocks, extractor.address);
        },
        async getData(services, blocks) {
            return await getPersistedLogs(services, [extractor.address], blocks);
        },
    }));
}
exports.makeRawLogExtractors = makeRawLogExtractors;
async function extractRawLogs(services, blocks, address) {
    const wholeExtractTimer = timer_1.timer('whole-extract');
    const gettingLogs = timer_1.timer('getting-logs');
    const logs = await getLogs(services, blocks, address);
    gettingLogs();
    const processingLogs = timer_1.timer(`processing-logs`, `with: ${logs.length}`);
    const blocksByHash = lodash_1.groupBy(blocks, 'hash');
    const allTxs = lodash_1.uniqBy(logs.map((l) => ({ txHash: l.transactionHash, blockHash: l.blockHash })), 'txHash');
    const allStoredTxs = await Promise.all(allTxs.map((tx) => common_1.getOrCreateTx(services, tx.txHash, blocksByHash[tx.blockHash][0])));
    const allStoredTxsByTxHash = lodash_1.groupBy(allStoredTxs, 'hash');
    const logsToInsert = (await Promise.all(logs.map(async (log) => {
        const _block = blocksByHash[log.blockHash];
        if (!_block) {
            return;
        }
        const block = _block[0];
        const storedTx = allStoredTxsByTxHash[log.transactionHash][0];
        return {
            ...log,
            address: log.address.toLowerCase(),
            log_index: log.logIndex,
            block_id: block.id,
            tx_id: storedTx.id,
        };
    }))).filter((log) => !!log);
    processingLogs();
    let insertedLogs = [];
    if (logsToInsert.length !== 0) {
        const addingLogs = timer_1.timer(`adding-logs`, `with: ${logsToInsert.length} logs`);
        const query = services.pg.helpers.insert(logsToInsert, services.columnSets['extracted_logs']) + ' RETURNING *';
        insertedLogs = await services.tx.many(query);
        addingLogs();
    }
    wholeExtractTimer();
    return insertedLogs;
}
exports.extractRawLogs = extractRawLogs;
async function getPersistedLogs(services, addresses, blocks) {
    if (addresses.length === 0) {
        return [];
    }
    const blocksIds = blocks.map((b) => b.id);
    const minId = lodash_1.min(blocksIds);
    const maxId = lodash_1.max(blocksIds);
    //@ts-ignore
    const extractedSchema = services.config.extractedSchema;
    return ((await services.tx.manyOrNone(`
SELECT * FROM ${extractedSchema}.logs
WHERE logs.block_id >= \${id_min} AND logs.block_id <= \${id_max} AND address IN (\${addresses:csv});
  `, {
        addresses,
        id_min: minId,
        id_max: maxId,
    })) || []);
}
exports.getPersistedLogs = getPersistedLogs;
function getExtractorName(address) {
    return `raw_log_${address.toLowerCase()}_extractor`;
}
exports.getExtractorName = getExtractorName;
async function getLogs(services, blocks, address) {
    if (blocks.length === 0) {
        return [];
    }
    else if (blocks.length === 1 && !getNetworkState_1.isDijets(services.networkState)) {
        // note: ganache doesnt support this RPC call so we avoid id
        return await services.provider.getLogs({
            address,
            blockHash: blocks[0].hash,
        });
    }
    else {
        const fromBlock = blocks[0].number;
        const toBlock = arrays_1.getLast(blocks).number;
        return await services.provider.getLogs({
            address,
            fromBlock,
            toBlock,
        });
    }
}
exports.getLogs = getLogs;
//# sourceMappingURL=rawEventDataExtractor.js.map