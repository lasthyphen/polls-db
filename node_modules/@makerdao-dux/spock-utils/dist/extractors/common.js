"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetryableError = exports.silenceError = exports.matchDeadlockDetectedError = exports.matchUniqueKeyError = exports.matchMissingForeignKeyError = exports.addTx = exports.getTxByIdOrDie = exports.getTx = exports.getOrCreateTx = exports.DEFAULT_ADDRESS = void 0;
exports.DEFAULT_ADDRESS = '0x0000000000000000000000000000000000000000';
const db_1 = require("@makerdao-dux/spock-etl/dist/db/db");
const ts_essentials_1 = require("ts-essentials");
async function getOrCreateTx(services, transactionHash, block) {
    const transaction = await services.provider.getTransaction(transactionHash);
    ts_essentials_1.assert(transaction, `Tx (${transactionHash}) couldn't be found - probably reorg is in progress`);
    const storedTx = await addTx(services, transaction, block);
    return storedTx;
}
exports.getOrCreateTx = getOrCreateTx;
async function getTx({ tx, processorSchema }, txHash) {
    return tx
        .oneOrNone(`
  SELECT * FROM ${processorSchema}.transaction
  WHERE hash=\${txHash}
  `, { txHash })
        .then(db_1.makeNullUndefined);
}
exports.getTx = getTx;
async function getTxByIdOrDie({ tx, processorSchema }, txId) {
    return tx
        .oneOrNone(`
  SELECT * FROM ${processorSchema}.transaction
  WHERE id=\${txId}
  `, { txId })
        .then(db_1.makeNullUndefined)
        .then((r) => {
        if (!r) {
            throw new Error(`Tx(id=${txId}) is missing`);
        }
        return r;
    });
}
exports.getTxByIdOrDie = getTxByIdOrDie;
async function addTx(services, transaction, block) {
    const { tx, processorSchema } = services;
    await tx
        .none(`
    INSERT INTO ${processorSchema}.transaction (hash, to_address, from_address, block_id, nonce, value, gas_limit, gas_price, data) VALUES(\${hash}, \${to}, \${from}, \${block_id}, \${nonce}, \${value}, \${gas_limit}, \${gas_price}, \${data})
    ON CONFLICT DO NOTHING
  `, {
        hash: transaction.hash,
        to: (transaction.to || exports.DEFAULT_ADDRESS).toLowerCase(),
        from: transaction.from && transaction.from.toLowerCase(),
        block_id: block.id,
        nonce: transaction.nonce,
        value: transaction.value.toString(),
        gas_limit: transaction.gasLimit.toString(),
        gas_price: transaction.gasPrice.toString(),
        data: transaction.data,
    })
        .catch(exports.silenceError(matchUniqueKeyError));
    const storedTx = await getTx(services, transaction.hash);
    ts_essentials_1.assert(storedTx, 'storedTx MUST be defined');
    return storedTx;
}
exports.addTx = addTx;
function matchMissingForeignKeyError(e) {
    return e.code === '23503';
}
exports.matchMissingForeignKeyError = matchMissingForeignKeyError;
function matchUniqueKeyError(e) {
    return e.code === '23505';
}
exports.matchUniqueKeyError = matchUniqueKeyError;
function matchDeadlockDetectedError(e) {
    return e.code === '40P01';
}
exports.matchDeadlockDetectedError = matchDeadlockDetectedError;
exports.silenceError = (...matchers) => (e) => {
    const matched = matchers.filter((m) => m(e)).length > 0;
    if (!matched) {
        throw e;
    }
};
class RetryableError extends Error {
}
exports.RetryableError = RetryableError;
//# sourceMappingURL=common.js.map