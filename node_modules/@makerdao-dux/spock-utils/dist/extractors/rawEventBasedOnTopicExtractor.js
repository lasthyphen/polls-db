"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLogsBasedOnTopics = exports.getExtractorName = exports.getPersistedLogsByTopic = exports.extractRawLogsOnTopic = exports.makeRawEventBasedOnTopicExtractor = void 0;
const getNetworkState_1 = require("@makerdao-dux/spock-etl/dist/ethereum/getNetworkState");
const arrays_1 = require("@makerdao-dux/spock-etl/dist/utils/arrays");
const timer_1 = require("@makerdao-dux/spock-etl/dist/utils/timer");
const ethers_1 = require("ethers");
const lodash_1 = require("lodash");
const common_1 = require("./common");
function makeRawEventBasedOnTopicExtractor(abis) {
    return abis.map((abi) => {
        const iface = new ethers_1.ethers.utils.Interface(abi.abi);
        const allTopics = Object.values(iface.events).map((e) => e.topic);
        return {
            name: getExtractorName(abi.name),
            startingBlock: abi.startingBlock,
            address: abi,
            extract: async (services, blocks) => {
                await extractRawLogsOnTopic(services, blocks, allTopics);
            },
            async getData(services, blocks) {
                return await getPersistedLogsByTopic(services, allTopics, blocks);
            },
        };
    });
}
exports.makeRawEventBasedOnTopicExtractor = makeRawEventBasedOnTopicExtractor;
async function extractRawLogsOnTopic(services, blocks, topics) {
    const logs = await getLogsBasedOnTopics(services, blocks, topics);
    const blocksByHash = lodash_1.groupBy(blocks, 'hash');
    const allTxs = lodash_1.uniqBy(logs.map((l) => ({ txHash: l.transactionHash, blockHash: l.blockHash })), 'txHash');
    const allStoredTxs = await Promise.all(allTxs.map((tx) => common_1.getOrCreateTx(services, tx.txHash, blocksByHash[tx.blockHash][0])));
    const allStoredTxsByTxHash = lodash_1.groupBy(allStoredTxs, 'hash');
    const logsToInsert = (await Promise.all(logs.map(async (log) => {
        const _block = blocksByHash[log.blockHash];
        // eslint-disable-next-line
        if (!_block) {
            return;
        }
        const block = _block[0];
        const storedTx = allStoredTxsByTxHash[log.transactionHash][0];
        return {
            ...log,
            address: log.address.toLowerCase(),
            log_index: log.logIndex,
            block_id: block.id,
            tx_id: storedTx.id,
        };
    }))).filter((log) => !!log);
    let insertedLogs = [];
    if (logsToInsert.length !== 0) {
        const addingLogs = timer_1.timer(`adding-logs`, `with: ${logsToInsert.length} logs`);
        const query = services.pg.helpers.insert(logsToInsert, services.columnSets['extracted_logs']) + ' RETURNING *';
        insertedLogs = await services.tx.many(query);
        addingLogs();
    }
    return insertedLogs;
}
exports.extractRawLogsOnTopic = extractRawLogsOnTopic;
async function getPersistedLogsByTopic(services, topics, blocks) {
    const blocksIds = blocks.map((b) => b.id);
    const minId = lodash_1.min(blocksIds);
    const maxId = lodash_1.max(blocksIds);
    //@ts-ignore
    const extractedSchema = services.config.extractedSchema;
    const result = (await services.tx.manyOrNone(`
  SELECT * FROM ${extractedSchema}.logs
  WHERE logs.block_id >= \${id_min} AND logs.block_id <= \${id_max} AND (
    ${topics.map((t) => `logs.topics LIKE '%${t}%'`).join(' OR ')}
  );
    `, {
        id_min: minId,
        id_max: maxId,
    })) || [];
    return result;
}
exports.getPersistedLogsByTopic = getPersistedLogsByTopic;
function getExtractorName(name) {
    return `raw_log_topic_${name}_extractor`;
}
exports.getExtractorName = getExtractorName;
async function getLogsBasedOnTopics(services, blocks, topics) {
    // we want to find any matching topic so we construct OR request
    // docs: https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_newfilter
    const topicsRequest = [topics];
    if (blocks.length === 0) {
        return [];
    }
    else if (blocks.length === 1 && !getNetworkState_1.isDijets(services.networkState)) {
        // note: ganache doesnt support this RPC call so we avoid id
        return await services.provider.getLogs({
            blockHash: blocks[0].hash,
            topics: topicsRequest,
        });
    }
    else {
        const fromBlock = blocks[0].number;
        const toBlock = arrays_1.getLast(blocks).number;
        return await services.provider.getLogs({
            topics: topicsRequest,
            fromBlock,
            toBlock,
        });
    }
}
exports.getLogsBasedOnTopics = getLogsBasedOnTopics;
//# sourceMappingURL=rawEventBasedOnTopicExtractor.js.map