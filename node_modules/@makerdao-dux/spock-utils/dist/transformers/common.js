"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleDsNoteEvents = exports.handleEvents = void 0;
const ethers_1 = require("ethers");
const lodash_1 = require("lodash");
const tryParseDsNote_1 = require("./tryParseDsNote");
/**
 * Decode events from raw logs using provided ABI.
 *
 * @param handlers - Keys are event names.
 *
 * NOTE: make sure that for the same ABI you always provide same object (reference). Otherwise this can lead to memory leaks.
 * NOTE: For support for DSNote generated events use "handleDsNoteEvents"
 */
async function handleEvents(services, abi, logs, handlers) {
    const iface = new ethers_1.ethers.utils.Interface(abi);
    // @todo sanity check for handlers is to check if event names exist in ABI
    const parsedEvents = logs.map((l) => {
        const topics = l.topics;
        const newTopics = topics.slice(1, topics.length - 1).split(',');
        const event = iface.parseLog({ data: l.data, topics: newTopics });
        if (!event) {
            return;
        }
        // we want to split positional arguments from named arguments,
        // this turns out to be a PITA because they are merged together inside parsedEvent.values object/array thing
        const eventDefinition = iface.events[event.signature].inputs;
        const paramsNames = eventDefinition.map((p) => p.name);
        const params = {};
        for (const p of paramsNames) {
            if (p) {
                params[p] = event.values[p];
            }
        }
        const args = [];
        for (let i = 0; i < eventDefinition.length; i++) {
            args.push(event.values[i]);
        }
        return {
            name: event.name,
            address: l.address.toLowerCase(),
            args,
            params,
        };
    });
    if (parsedEvents.length !== logs.length) {
        throw new Error('Length mismatch');
    }
    const fullEventInfo = lodash_1.zip(parsedEvents, logs).map(([event, log]) => ({
        event,
        log: log,
    }));
    for (const handlerName of Object.keys(handlers)) {
        const handler = handlers[handlerName];
        // @todo we could group all events once
        const filteredEvents = fullEventInfo.filter((e) => e.event && e.event.name === handlerName);
        await Promise.all(filteredEvents.map((e) => handler(services, e)));
    }
}
exports.handleEvents = handleEvents;
/**
 * Decode dsnote generated anonymous events.
 *
 * @param handlers - Keys are method signatures.
 * @param version - There are two different DSNotes versions in the wild. DsNote Ver 2 doesnt encode call value, it's used in MCD.
 */
async function handleDsNoteEvents(services, abi, logs, handlers, version = 1) {
    const iface = new ethers_1.ethers.utils.Interface(abi);
    const parsedNotes = logs.map((l) => {
        const explodedTopics = l.topics.slice(1, l.topics.length - 1).split(',');
        const parsedNote = version === 2 ? tryParseDsNote_1.tryParseDsNoteVer2(explodedTopics, l.data) : tryParseDsNote_1.tryParseDsNote(explodedTopics, l.data);
        if (!parsedNote) {
            return;
        }
        const decodedCallData = iface.parseTransaction({ data: parsedNote.values.fax });
        // // it might be a standard log so we won't decode it
        if (!decodedCallData) {
            return;
        }
        // // we need to query abi and get args names b/c ethers won't return them
        // // NOTE: there might be no named args and thus you will have to use positional args
        const names = iface.functions[decodedCallData.signature].inputs.map((i) => i.name);
        const params = {};
        for (const [i, param] of decodedCallData.args.entries()) {
            const name = names[i];
            if (name !== undefined) {
                params[name] = param;
            }
        }
        return {
            name: decodedCallData.signature,
            args: decodedCallData.args,
            params,
            ethValue: parsedNote.values.wad && parsedNote.values.wad.toString(10),
            caller: parsedNote.values.guy.toLowerCase(),
        };
    });
    if (parsedNotes.length !== logs.length) {
        throw new Error('Length mismatch');
    }
    const fullEventInfo = lodash_1.zip(parsedNotes, logs).map(([note, log]) => ({ note, log }));
    const promises = fullEventInfo.map(async (info) => {
        if (!info.note) {
            return;
        }
        const handler = handlers[info.note.name];
        if (!handler) {
            return;
        }
        await handler(services, info);
    });
    await Promise.all(promises);
}
exports.handleDsNoteEvents = handleDsNoteEvents;
//# sourceMappingURL=common.js.map