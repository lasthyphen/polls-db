import { LocalServices } from '@makerdao-dux/spock-etl/dist/services/types';
import { Dictionary } from 'ts-essentials';
import { PersistedLog } from '../extractors/rawEventDataExtractor';
/**
 * Decode events from raw logs using provided ABI.
 *
 * @param handlers - Keys are event names.
 *
 * NOTE: make sure that for the same ABI you always provide same object (reference). Otherwise this can lead to memory leaks.
 * NOTE: For support for DSNote generated events use "handleDsNoteEvents"
 */
export declare function handleEvents<TServices>(services: TServices, abi: any, logs: PersistedLog[], handlers: EventHandlers<TServices>): Promise<void>;
/**
 * Decode dsnote generated anonymous events.
 *
 * @param handlers - Keys are method signatures.
 * @param version - There are two different DSNotes versions in the wild. DsNote Ver 2 doesnt encode call value, it's used in MCD.
 */
export declare function handleDsNoteEvents(services: LocalServices, abi: any, logs: PersistedLog[], handlers: DsNoteHandlers, version?: 1 | 2): Promise<void>;
interface NoteDecoded {
    name: string;
    args: Array<any>;
    params: Dictionary<any>;
    ethValue?: string;
    caller: string;
}
export interface ParsedEvent {
    address: string;
    name: string;
    args: Array<any>;
    params: Dictionary<any>;
}
export interface FullEventInfo {
    event: ParsedEvent;
    log: PersistedLog;
}
export interface FullEventInfoUnfiltered {
    event?: ParsedEvent;
    log: PersistedLog;
}
export interface FullNoteEventInfo {
    note: NoteDecoded;
    log: PersistedLog;
}
export interface FullNoteEventInfoUnfiltered {
    note?: NoteDecoded;
    log: PersistedLog;
}
declare type Handler<TServices> = (services: TServices, info: FullEventInfo) => Promise<void>;
export declare type EventHandlers<TServices> = Dictionary<Handler<TServices>>;
declare type DsNoteHandler = (services: LocalServices, info: FullNoteEventInfo) => Promise<void>;
export declare type DsNoteHandlers = Dictionary<DsNoteHandler>;
export {};
