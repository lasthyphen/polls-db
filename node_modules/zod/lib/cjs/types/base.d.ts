import { util } from "../helpers/util";
import { ZodTypes } from "../ZodTypes";
import { ParseParams } from "../parser";
import { ZodCustomIssue, ZodError, MakeErrorData } from "../ZodError";
export declare type RefinementCtx = {
    addIssue: (arg: MakeErrorData) => void;
    path: (string | number)[];
};
export declare type ZodRawShape = {
    [k: string]: ZodTypeAny;
};
export declare type TypeOf<T extends ZodType<any>> = T["_output"];
export declare type input<T extends ZodType<any>> = T["_input"];
export declare type output<T extends ZodType<any>> = T["_output"];
export declare type infer<T extends ZodType<any>> = T["_output"];
export declare type ZodTypeAny = ZodType<any, any, any>;
import { ZodArray, ZodNullableType, ZodOptionalType, ZodTransformer } from "../index";
declare type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
declare type InternalCheck<T> = {
    check: (arg: T, ctx: RefinementCtx) => any;
};
export declare function declareZodType(): void;
export interface ZodTypeDef {
    t: ZodTypes;
    checks?: InternalCheck<any>[];
    accepts?: ZodType<any, any>;
}
export declare abstract class ZodType<Output, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {
    readonly _type: Output;
    readonly _output: Output;
    readonly _input: Input;
    readonly _def: Def;
    parse: (x: unknown, params?: ParseParams) => Output;
    safeParse: (x: unknown, params?: ParseParams) => {
        success: true;
        data: Output;
    } | {
        success: false;
        error: ZodError;
    };
    parseAsync: (x: unknown, params?: ParseParams) => Promise<Output>;
    safeParseAsync: (x: unknown, params?: ParseParams) => Promise<{
        success: true;
        data: Output;
    } | {
        success: false;
        error: ZodError;
    }>;
    spa: (x: unknown, params?: ParseParams | undefined) => Promise<{
        success: true;
        data: Output;
    } | {
        success: false;
        error: ZodError;
    }>;
    is(u: Input): u is Input;
    check(u: unknown): u is Input;
    refine: <Func extends (arg: Output) => any>(check: Func, message?: string | Partial<Pick<ZodCustomIssue, "path" | "message" | "params">> | ((arg: Output) => CustomErrorParams)) => this;
    refinement: (check: (arg: Output) => any, refinementData: (Pick<import("..").ZodInvalidTypeIssue, "code" | "expected" | "received" | "message"> & {
        path?: (string | number)[] | undefined;
    }) | (Pick<import("..").ZodNonEmptyArrayIsEmptyIssue, "code" | "message"> & {
        path?: (string | number)[] | undefined;
    }) | (Pick<import("..").ZodUnrecognizedKeysIssue, "keys" | "code" | "message"> & {
        path?: (string | number)[] | undefined;
    }) | (Pick<import("..").ZodInvalidUnionIssue, "code" | "message" | "unionErrors"> & {
        path?: (string | number)[] | undefined;
    }) | (Pick<import("..").ZodInvalidLiteralValueIssue, "code" | "expected" | "message"> & {
        path?: (string | number)[] | undefined;
    }) | (Pick<import("..").ZodInvalidEnumValueIssue, "code" | "message" | "options"> & {
        path?: (string | number)[] | undefined;
    }) | (Pick<import("..").ZodInvalidArgumentsIssue, "code" | "message" | "argumentsError"> & {
        path?: (string | number)[] | undefined;
    }) | (Pick<import("..").ZodInvalidReturnTypeIssue, "code" | "message" | "returnTypeError"> & {
        path?: (string | number)[] | undefined;
    }) | (Pick<import("..").ZodInvalidDateIssue, "code" | "message"> & {
        path?: (string | number)[] | undefined;
    }) | (Pick<import("..").ZodInvalidStringIssue, "code" | "message" | "validation"> & {
        path?: (string | number)[] | undefined;
    }) | (Pick<import("..").ZodTooSmallIssue, "code" | "message" | "minimum" | "inclusive" | "type"> & {
        path?: (string | number)[] | undefined;
    }) | (Pick<import("..").ZodTooBigIssue, "code" | "message" | "inclusive" | "type" | "maximum"> & {
        path?: (string | number)[] | undefined;
    }) | (Pick<import("..").ZodInvalidIntersectionTypesIssue, "code" | "message"> & {
        path?: (string | number)[] | undefined;
    }) | (Pick<ZodCustomIssue, "code" | "message" | "params"> & {
        path?: (string | number)[] | undefined;
    }) | ((arg: Output, ctx: RefinementCtx) => MakeErrorData)) => this;
    _refinement: (refinement: InternalCheck<Output>["check"]) => this;
    constructor(def: Def);
    abstract toJSON: () => object;
    optional: () => ZodOptionalType<this>;
    or: () => ZodOptionalType<this>;
    nullable: () => ZodNullableType<this>;
    array: () => ZodArray<this>;
    transform<This extends this, U extends ZodType<any>, Tx extends (arg: This["_output"]) => U["_input"] | Promise<U["_input"]>>(input: U, transformer: Tx): ZodTransformer<This, U>;
    transform<This extends this, Tx extends (arg: This["_output"]) => This["_output"] | Promise<This["_output"]>>(transformer: Tx): ZodTransformer<This, This>;
    default<T extends Input = Input, Opt extends ReturnType<this["optional"]> = ReturnType<this["optional"]>>(def: T): ZodTransformer<Opt, this>;
    default<T extends (arg: this) => Input, Opt extends ReturnType<this["optional"]> = ReturnType<this["optional"]>>(def: T): ZodTransformer<Opt, this>;
    isOptional: () => boolean;
    isNullable: () => boolean;
}
export {};
