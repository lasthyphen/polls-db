import { objectUtil } from "../helpers/objectUtil";
import { partialUtil } from "../helpers/partialUtil";
import { Scalars } from "../helpers/primitive";
import { ZodTypes } from "../ZodTypes";
import { ZodRawShape, ZodType, ZodTypeDef, ZodTypeAny } from "./base";
export declare const mergeObjects: <First extends AnyZodObject>(first: First) => <Second extends AnyZodObject>(second: Second) => ZodObject<First["_shape"] & Second["_shape"], First["_unknownKeys"], First["_catchall"], objectOutputType<First["_shape"] & Second["_shape"], First["_catchall"]>, objectInputType<First["_shape"] & Second["_shape"], First["_catchall"]>>;
declare type UnknownKeysParam = "passthrough" | "strict" | "strip";
export interface ZodObjectDef<T extends ZodRawShape = ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    t: ZodTypes.object;
    shape: () => T;
    catchall: Catchall;
    unknownKeys: UnknownKeys;
}
export declare type baseObjectOutputType<Shape extends ZodRawShape> = objectUtil.flatten<objectUtil.addQuestionMarks<{
    [k in keyof Shape]: Shape[k]["_output"];
}>>;
export declare type objectOutputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny> = ZodTypeAny extends Catchall ? baseObjectOutputType<Shape> : objectUtil.flatten<baseObjectOutputType<Shape> & {
    [k: string]: Catchall["_output"];
}>;
export declare type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.flatten<objectUtil.addQuestionMarks<{
    [k in keyof Shape]: Shape[k]["_input"];
}>>;
export declare type objectInputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny> = ZodTypeAny extends Catchall ? baseObjectInputType<Shape> : objectUtil.flatten<baseObjectInputType<Shape> & {
    [k: string]: Catchall["_input"];
}>;
export declare class ZodObject<T extends ZodRawShape, UnknownKeys extends UnknownKeysParam = "passthrough", Catchall extends ZodTypeAny = ZodTypeAny, Output = objectOutputType<T, Catchall>, Input = objectInputType<T, Catchall>> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {
    readonly _shape: T;
    readonly _unknownKeys: UnknownKeys;
    readonly _catchall: Catchall;
    get shape(): T;
    toJSON: () => {
        t: ZodTypes.object;
        shape: any;
    };
    strict: () => ZodObject<T, "strict", Catchall>;
    strip: () => ZodObject<T, "strip", Catchall>;
    passthrough: () => ZodObject<T, "passthrough", Catchall>;
    nonstrict: () => ZodObject<T, "passthrough", Catchall>;
    augment: <Augmentation extends ZodRawShape>(augmentation: Augmentation) => ZodObject<{ [k in Exclude<keyof T, keyof Augmentation>]: T[k]; } & { [k_1 in keyof Augmentation]: Augmentation[k_1]; }, UnknownKeys, Catchall, objectOutputType<{ [k in Exclude<keyof T, keyof Augmentation>]: T[k]; } & { [k_1 in keyof Augmentation]: Augmentation[k_1]; }, Catchall>, objectInputType<{ [k in Exclude<keyof T, keyof Augmentation>]: T[k]; } & { [k_1 in keyof Augmentation]: Augmentation[k_1]; }, Catchall>>;
    extend: <Augmentation extends ZodRawShape>(augmentation: Augmentation) => ZodObject<{ [k in Exclude<keyof T, keyof Augmentation>]: T[k]; } & { [k_1 in keyof Augmentation]: Augmentation[k_1]; }, UnknownKeys, Catchall, objectOutputType<{ [k in Exclude<keyof T, keyof Augmentation>]: T[k]; } & { [k_1 in keyof Augmentation]: Augmentation[k_1]; }, Catchall>, objectInputType<{ [k in Exclude<keyof T, keyof Augmentation>]: T[k]; } & { [k_1 in keyof Augmentation]: Augmentation[k_1]; }, Catchall>>;
    setKey: <Key extends string, Schema extends ZodTypeAny>(key: Key, schema: Schema) => ZodObject<T & { [k in Key]: Schema; }, UnknownKeys, Catchall, objectOutputType<T & { [k in Key]: Schema; }, Catchall>, objectInputType<T & { [k in Key]: Schema; }, Catchall>>;
    merge: <Incoming extends AnyZodObject>(other: Incoming) => ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall>;
    catchall: <Index extends ZodTypeAny>(index: Index) => ZodObject<T, UnknownKeys, Index, objectOutputType<T, Index>, objectInputType<T, Index>>;
    pick: <Mask extends { [k in keyof T]?: true | undefined; }>(mask: Mask) => ZodObject<{ [k_2 in objectUtil.NoNeverKeys<{ [k_1 in keyof Mask]: k_1 extends keyof T ? T[k_1] : never; }>]: k_2 extends keyof Mask ? { [k_1 in keyof Mask]: k_1 extends keyof T ? T[k_1] : never; }[k_2] : never; }, UnknownKeys, Catchall, objectOutputType<{ [k_2 in objectUtil.NoNeverKeys<{ [k_1 in keyof Mask]: k_1 extends keyof T ? T[k_1] : never; }>]: k_2 extends keyof Mask ? { [k_1 in keyof Mask]: k_1 extends keyof T ? T[k_1] : never; }[k_2] : never; }, Catchall>, objectInputType<{ [k_2 in objectUtil.NoNeverKeys<{ [k_1 in keyof Mask]: k_1 extends keyof T ? T[k_1] : never; }>]: k_2 extends keyof Mask ? { [k_1 in keyof Mask]: k_1 extends keyof T ? T[k_1] : never; }[k_2] : never; }, Catchall>>;
    omit: <Mask extends { [k in keyof T]?: true | undefined; }>(mask: Mask) => ZodObject<{ [k_2 in objectUtil.NoNeverKeys<{ [k_1 in keyof T]: k_1 extends keyof Mask ? never : T[k_1]; }>]: k_2 extends keyof T ? { [k_1 in keyof T]: k_1 extends keyof Mask ? never : T[k_1]; }[k_2] : never; }, UnknownKeys, Catchall, objectOutputType<{ [k_2 in objectUtil.NoNeverKeys<{ [k_1 in keyof T]: k_1 extends keyof Mask ? never : T[k_1]; }>]: k_2 extends keyof T ? { [k_1 in keyof T]: k_1 extends keyof Mask ? never : T[k_1]; }[k_2] : never; }, Catchall>, objectInputType<{ [k_2 in objectUtil.NoNeverKeys<{ [k_1 in keyof T]: k_1 extends keyof Mask ? never : T[k_1]; }>]: k_2 extends keyof T ? { [k_1 in keyof T]: k_1 extends keyof Mask ? never : T[k_1]; }[k_2] : never; }, Catchall>>;
    partial: () => ZodObject<{ [k in keyof T]: ReturnType<T[k]["optional"]>; }, UnknownKeys, Catchall, objectOutputType<{ [k in keyof T]: ReturnType<T[k]["optional"]>; }, Catchall>, objectInputType<{ [k in keyof T]: ReturnType<T[k]["optional"]>; }, Catchall>>;
    primitives: () => ZodObject<{ [k_1 in objectUtil.NoNeverKeys<{ [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? T[k] : never; }>]: k_1 extends keyof T ? { [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? T[k] : never; }[k_1] : never; }, UnknownKeys, Catchall, objectOutputType<{ [k_1 in objectUtil.NoNeverKeys<{ [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? T[k] : never; }>]: k_1 extends keyof T ? { [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? T[k] : never; }[k_1] : never; }, Catchall>, objectInputType<{ [k_1 in objectUtil.NoNeverKeys<{ [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? T[k] : never; }>]: k_1 extends keyof T ? { [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? T[k] : never; }[k_1] : never; }, Catchall>>;
    nonprimitives: () => ZodObject<{ [k_1 in objectUtil.NoNeverKeys<{ [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? never : T[k]; }>]: k_1 extends keyof T ? { [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? never : T[k]; }[k_1] : never; }, UnknownKeys, Catchall, objectOutputType<{ [k_1 in objectUtil.NoNeverKeys<{ [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? never : T[k]; }>]: k_1 extends keyof T ? { [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? never : T[k]; }[k_1] : never; }, Catchall>, objectInputType<{ [k_1 in objectUtil.NoNeverKeys<{ [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? never : T[k]; }>]: k_1 extends keyof T ? { [k in keyof T]: [T[k]["_output"]] extends [Scalars] ? never : T[k]; }[k_1] : never; }, Catchall>>;
    deepPartial: () => partialUtil.RootDeepPartial<this>;
    static create: <T_1 extends ZodRawShape>(shape: T_1) => ZodObject<T_1, "passthrough", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k]["_output"]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k]["_output"]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2]["_input"]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2]["_input"]; }>[k_3]; }>;
    static lazycreate: <T_1 extends ZodRawShape>(shape: () => T_1) => ZodObject<T_1, "passthrough", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k]["_output"]; }>]: objectUtil.addQuestionMarks<{ [k in keyof T_1]: T_1[k]["_output"]; }>[k_1]; }, { [k_3 in keyof objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2]["_input"]; }>]: objectUtil.addQuestionMarks<{ [k_2 in keyof T_1]: T_1[k_2]["_input"]; }>[k_3]; }>;
}
export declare type AnyZodObject = ZodObject<any, any, any>;
export {};
